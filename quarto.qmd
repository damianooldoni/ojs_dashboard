---
title: "Species Dashboard"
format: 
  html:
    page-layout: custom
    self-contained: true
---

<style>
body {
  margin: 0;
  padding: 0;
  overflow: hidden;
}

.dashboard-container {
  display: flex;
  height: 100vh;
  gap: 0;
}

.left-panel {
  width: 350px;
  padding: 20px;
  background-color: #f8f9fa;
  overflow-y: auto;
  box-shadow: 2px 0 4px rgba(0,0,0,0.1);
}

.right-panel {
  flex: 1;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

.map-container {
  flex: 1;
  position: relative;
  overflow: hidden;
}

.map-container > div {
  height: 100% !important;
  width: 100% !important;
}
</style>
</style>

```{r}
#| echo: false
#| warning: false
library(ggplot2)
library(sf)
library(jsonlite)
library(base64enc)

# Your data
polygons_sf <- st_read(system.file("shape/nc.shp", package="sf"), quiet = TRUE)
polygons_sf$id <- 1:nrow(polygons_sf)

# Create example plots for each species and polygon
species <- c("Species A", "Species B", "Species C")

# Convert plots to base64 PNG images for embedding
plots_data <- list()
for(sp in species) {
  for(i in 1:nrow(polygons_sf)) {
    gg_plot <- ggplot(data.frame(x = 1:10, y = rnorm(10, mean = i))) +
      geom_line(aes(x, y), color = "steelblue", linewidth = 1) +
      geom_point(aes(x, y), color = "darkblue", size = 2) +
      labs(title = paste(sp, "- Polygon", polygons_sf$NAME[i])) +
      theme_minimal()
    
    # Save plot to temp file and convert to base64
    temp_file <- tempfile(fileext = ".png")
    ggsave(temp_file, gg_plot, width = 6, height = 4, dpi = 100)
    
    img_base64 <- base64enc::base64encode(temp_file)
    
    plots_data[[length(plots_data) + 1]] <- list(
      species = sp,
      polygon_id = i,
      polygon_name = polygons_sf$NAME[i],
      image = paste0("data:image/png;base64,", img_base64)
    )
    
    unlink(temp_file)
  }
}

# Convert spatial data to GeoJSON
geojson_data <- sf::st_transform(polygons_sf, 4326) # Convert to WGS84
geojson_data$polygon_id <- 1:nrow(geojson_data)
geojson_text <- geojsonsf::sf_geojson(geojson_data)

# Pass data to OJS
ojs_define(plots_data_r = plots_data)
ojs_define(geojson_text_r = geojson_text)
```


```{ojs}
//| echo: false
// Import required libraries
L = require("leaflet@1.9.4")
d3 = require("d3@7")
```

```{ojs}
//| echo: false
// Parse the data - plots_data_r is already an array of objects from R
plots_json = plots_data_r
geo_data = JSON.parse(geojson_text_r)

// Create a reactive variable for selected polygon
mutable selected_polygon_id = null

// Filter plots by selected species
filtered_plots = plots_json.filter(d => d.species === selected_species)
```

::: {.dashboard-container}

::: {.left-panel}
```{ojs}
//| echo: false
// Species selector
viewof selected_species = Inputs.select(
  ["Species A", "Species B", "Species C"],
  {label: "Select Species:", value: "Species A"}
)
```

```{ojs}
//| echo: false
// Display the selected plot
plot_display = {
  if (selected_polygon_id === null) {
    return html`<div style="padding: 20px; text-align: center; color: #666;">
      <p>Click on a polygon to view the plot</p>
    </div>`;
  }
  
  const plot = filtered_plots.find(d => d.polygon_id === selected_polygon_id);
  
  if (!plot) {
    return html`<div style="padding: 20px;">No plot available</div>`;
  }
  
  return html`<div style="text-align: center;">
    <h4>${plot.species} - ${plot.polygon_name}</h4>
    <img src="${plot.image}" style="max-width: 100%; height: auto; border: 1px solid #ddd; border-radius: 4px;">
  </div>`;
}
```
:::

::: {.right-panel}
::: {.map-container}
```{ojs}
//| echo: false
// Create the map
map_container = {
  const container = DOM.element('div', { style: 'height: 100%; width: 100%;' });
  
  yield container;
  
  // Small delay to ensure container is in DOM
  await new Promise(resolve => setTimeout(resolve, 100));
  
  const map = L.map(container, {
    zoomSnap: 0.25,
    zoomDelta: 0.5,
    wheelPxPerZoomLevel: 120
  });
  
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: 'Â© OpenStreetMap contributors'
  }).addTo(map);
  
  const geojsonLayer = L.geoJSON(geo_data, {
    style: {
      fillColor: 'blue',
      fillOpacity: 0.3,
      color: 'black',
      weight: 1
    },
    onEachFeature: function(feature, layer) {
      layer.on({
        click: function(e) {
          // Update selected polygon
          mutable selected_polygon_id = feature.properties.polygon_id;
          
          // Reset all styles
          geojsonLayer.eachLayer(l => {
            l.setStyle({
              fillColor: 'blue',
              fillOpacity: 0.3,
              weight: 1
            });
          });
          
          // Highlight selected
          layer.setStyle({
            fillColor: 'red',
            fillOpacity: 0.5,
            weight: 3
          });
        },
        mouseover: function(e) {
          if (feature.properties.polygon_id !== selected_polygon_id) {
            layer.setStyle({
              fillOpacity: 0.5,
              weight: 2
            });
          }
        },
        mouseout: function(e) {
          if (feature.properties.polygon_id !== selected_polygon_id) {
            layer.setStyle({
              fillOpacity: 0.3,
              weight: 1
            });
          }
        }
      });
    }
  }).addTo(map);
  
  // Fit bounds with padding and then invalidate size
  const bounds = geojsonLayer.getBounds();
  map.fitBounds(bounds, { padding: [20, 20] });
  
  // Force map to recalculate its size
  setTimeout(() => map.invalidateSize(), 200);
}
```
:::
:::

:::
